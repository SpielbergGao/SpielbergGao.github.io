<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LinkedList</title>
      <link href="/linkedlist/"/>
      <url>/linkedlist/</url>
      
        <content type="html"><![CDATA[<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 同时实现了 List 接口和 Deque 接口，所以既可以将 LinkedList 当做一个有序容器，也可以将之看作一个队列（Queue），同时又可以看作一个栈（Stack）。虽然 LinkedList 和 ArrayList 一样都实现了 List 接口，<br>但其底层是通过双向链表来实现的，所以 LinkedList 插入和删除元素的效率都要比 ArrayList 高，因此随机访问的效率也要比 ArrayList 低。</p><p>实现了List接口和Deque接口，是双端链表，支持高效的插入和删除操作，非线程安全如果需要线程安全可以使用 <code>Collections.synchronizedList(new LinkedList(...))</code></p><p><strong>先看看实例的时候做什么操作</strong></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 构造一个空列表。     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构造一个包含指定集合元素的列表，其顺序由集合的迭代器返回。     *     * @param  c 将其元素放入此列表的集合     * @throws NullPointerException-如果指定的集合为null     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>因为 LinkedList 使用的是链表结构，所以 LinkedList 不需要去请求一片连续的内存空间来存储数据，而是在每次有新的元素需要添加进来时，再来动态请求内存空间。</p><p><strong>成员变量</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 指向第一个节点的指针。     * Invariant: (first == null &amp;&amp; last == null) ||     *            (first.prev == null &amp;&amp; first.item != null)     */</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 指向最后一个节点的指针。     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     */</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 876323262645176354L<span class="token punctuation">;</span></code></pre><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 将指定的元素追加到此列表的末尾。     *     * &lt;p> 此方法等效于 {@link #addLast}.     *     * @param e 要添加到此列表的元素     * @return {@code true} (as specified by {@link Collection#add})     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将e链接为最后一个元素。     */</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>add(E e)</code> 方法用于向链表的尾部添加结点，因为有 <code>last</code> 指向链表的尾结点，因此向尾部添加新元素只需要修改几个引用即可，效率较高。</p><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 将指定的元素插入此列表中的指定位置。 将当前在该位置的元素（如果有）和任何后续元素右移（将其索引加一）。     *     * @param index 指定元素要插入的索引     * @param element 要插入的元素     * @throws IndexOutOfBoundsException {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>            <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将e链接为最后一个元素。     */</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 在非 null 节点 succ 之前插入元素 e。     */</span>    <span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> succ<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert succ != null;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>        succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>add(int index, E element)</code> 方法用于向指定索引处添加元素，需要先通过索引 <code>index</code> 获取相应位置的结点，并在该位置开辟一个新的结点来存储元素 <code>element</code>，最后还需要修改相邻结点间的引用</p><h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 从指定位置开始，将指定集合中的所有元素插入此列表。      * 将当前位于该位置的元素（如果有）和任何后续元素右移（增加其索引）。     * 新元素将按指定集合的迭代器返回的顺序显示在列表中。     *     * @param index 从指定集合插入第一个元素的索引     * @param c 包含要添加到此列表的元素的集合     * @return {@code true} 该列表是否因调用而改变     * @throws IndexOutOfBoundsException {@inheritDoc}     * @throws NullPointerException if the specified collection is null     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numNew <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> pred<span class="token punctuation">,</span> succ<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> null<span class="token punctuation">;</span>            pred <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            succ <span class="token operator">=</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Object o <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> E e <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> o<span class="token punctuation">;</span>            Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> null<span class="token punctuation">)</span>                first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            <span class="token keyword">else</span>                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>            pred <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>succ <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> succ<span class="token punctuation">;</span>            succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>首先对传入的 <code>index</code> 校验是否在 <code>size</code> 之内，通过 <code>c.toArray()</code> 获得一个数组并判断该数组的长度，<br>如果插入的位置是尾部，将前驱节点设置为 <code>last</code>,后继节点为 <code>null</code>，否则调用 <code>node()</code> 方法得到后继节点，<br>在获得前驱节点。然后开始便利数据并将数据插入，如果插入的位置在链表头部新建一个节点否则将指向下一个元素的前驱节点。<br>插入的位置是在末尾则重置 <code>last</code> 节点。</p><h3 id="unlinkFirst-Node-f-unlinkLast-Node-l-unlink-Node-x"><a href="#unlinkFirst-Node-f-unlinkLast-Node-l-unlink-Node-x" class="headerlink" title="unlinkFirst(Node f) unlinkLast(Node l) unlink(Node x)"></a>unlinkFirst(Node<E> f) unlinkLast(Node<E> l) unlink(Node<E> x)</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 取消链接非空的第一个节点f。     */</span>    <span class="token keyword">private</span> E <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert f == first &amp;&amp; f != null;</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        f<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        f<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>        first <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>            last <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">else</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 取消链接非空的最后一个节点l。     */</span>    <span class="token keyword">private</span> E <span class="token function">unlinkLast</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert l == last &amp;&amp; l != null;</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> l<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        l<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">else</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 取消链接非空节点x。     */</span>    E <span class="token function">unlink</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// assert x != null;</span>        <span class="token keyword">final</span> E element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            first <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> element<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>元素做移除操作都离不开上面三种方法，链表移除元素通过更改前后节点指向来完成。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/arraylist/"/>
      <url>/arraylist/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>看看 <code>ArrayList</code> 在创建实例的时候做了哪些任务。以下的注释为个人翻译夹杂个人理解如有不准可以自行查看原文。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 用于空实例的共享空数组。     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 共享的空数组实例，用于默认大小的空实例。     * 将它从 EMPTY_ELEMENTDATA 数组中区分出来，以知道在添加第一个元素时容量需要增加多少。     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 数组缓冲区，数组列表的元素存储在其中。     * 数组列表的容量是该数组缓冲区的长度。任何的     * 空数组列表 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA     * 将在添加第一个元素时扩展为 DEFAULT_CAPACITY。     */</span>    <span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span>    <span class="token comment" spellcheck="true">/**     * 构造一个具有指定初始容量的空列表。     *     * @param  initialCapacity  列表初始容量     * @throws 如果指定的初始容量为负抛出 IllegalArgumentException      */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构造一个初始容量为10的空列表。     */</span>    <span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>通过代码可以看到如果不指定其大小的时候默认大小是10，如果指定了大小则按照指定的容量进行设置，大小等于 0 的话则创建一个空数组的实例，大小为负数的话会抛出一个异常。</p><h3 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e) 方法"></a>add(E e) 方法</h3><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">/**         * 将指定的元素追加到列表的末尾。         *         * @param e 元素将添加到该列表中         * @return &lt;tt>true&lt;/tt> (as specified by {@link Collection#add})         */</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>            elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            modCount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// overflow-conscious code</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 要分配的数组的最大大小。         * 一些虚拟机在数组中保留一些 header words。         * 尝试分配更大的阵列可能会导致         * OutOfMemoryError: 请求的阵列大小超过虚拟机限制         */</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ARRAY_SIZE <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 增加容量以确保它至少可以容纳         * 最小容量参数指定的元素数量。         *         * @param minCapacity 所需的最小容量         */</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// overflow-conscious code</span>            <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 扩展为原来的 1.5 倍</span>            <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>            elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>                Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>                MAX_ARRAY_SIZE<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>可以看到它的实现其实最核心的内容就是ensureCapacityInternal。这个函数其实就是自动扩容机制的核心。依次来看一下他的具体实现。</p><p>当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们add10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示。</p><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">/**         * 在列表中的指定位置插入指定元素。         * 将当前位于该位置的元素         * （如果有）和任何后续元素向右移动（将一个元素添加到其索引中）。         *         * @param index 要插入指定元素的索引         * @param element 要插入的元素         * @throws IndexOutOfBoundsException {@inheritDoc}         */</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                             size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>            size<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>在指定索引处添加一个元素，先对 index 进行界限检查，然后调用 ensureCapacityInternal 方法保证 capacity 足够大，再将从 index 开始之后的所有成员后移一个位置，将 element 插入 index 位置，最后 size 加 1。<br>可以看出它比 add(index) 方法还要多一个 <code>System.arraycopy</code>。 </p><h3 id="set-和-get-函数"><a href="#set-和-get-函数" class="headerlink" title="set 和 get 函数"></a>set 和 get 函数</h3><h4 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">/**         * 用指定的元素替换列表中指定位置的元素。         *          *         * @param index 要替换元素的索引         * @param element 要存储在指定位置的元素         * @return 先前位于指定位置的元素         * @throws IndexOutOfBoundsException {@inheritDoc}         */</span>        <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>先做 index 检查，用指定的元素替换此列表中指定位置的元素。</p><h4 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h4><pre class=" language-java"><code class="language-java">        <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">elementData</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>modCount <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>modCount<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>  </code></pre><p>先做 index 检查，然后校验当前数组的结构是否有发生变化，如果发生变则抛出异常 <code>ConcurrentModificationException</code>。</p><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 数组列表的大小(它包含的元素数)。     *     * @serial     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 如果指定元素存在，则从中可移除该元素的第一个匹配项。这个     * 列表，如果列表不包含元素，它是不变的。更正式地说，可删除     * 索引最低的元素     * &lt;tt>i&lt;/tt> such that     * &lt;tt>(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt>     * (if such an element exists).  Returns &lt;tt>true&lt;/tt> if this list     * contained the specified element (or equivalently, if this list     * changed as a result of the call).     *     * @param o 要从此列表中可移除的元素（如果存在）     * @return &lt;tt>true&lt;/tt> 如果该列表包含指定的元素     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * 跳过边界检查和不返回删除的值的专有删除方法。     *      */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token punctuation">}</span></code></pre><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的</p><h3 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h3><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回列表中指定元素首次出现的索引，如果列表不包含该元素，     * 则返回-1。更正式地说，返回最低的指数     *      * &lt;tt>(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt>,     * 如果没有这样的索引，则为-1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可以看到，先判断查找的o对象是否为空，然后再去遍历所有的元素，然后返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1。最后判断如果此列表包含指定的元素，则返回true，否则返回false。</p><h3 id="System-arraycopy-和Arrays-copyOf"><a href="#System-arraycopy-和Arrays-copyOf" class="headerlink" title="System.arraycopy()和Arrays.copyOf()"></a>System.arraycopy()和Arrays.copyOf()</h3><p>以下的代码是从源码中找到的，比较长大部分是注释的内容可以直接看总结部分。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回一个副本，该细分按正确的顺序（从第一个元素到最后一个元素）包含列表中的所有元素。     * &lt;p>（换句话说，这个方法必须分配一个新数组）。因此，调用者可以自由修改返回的数组。     * &lt;p> 此方法充当基于数组的API和基于集合的API之间的桥梁。     * @return 包含此列表中所有元素的序列按适当顺序的数组     */</span>    <span class="token keyword">public</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 复制指定的数组，截断或填充为空（如果需要），以便副本具有指定的长度。 对于在原始数组和副本中均     * 有效的所有索引，两个数组将包含相同的值。 对于副本中有效但原始索引无效的任何索引，副本将包含     * &lt;tt> null &lt;/ tt>。 当且仅当指定长度大于原始数组的长度时，此类索引才会存在。 所得数组与原始数组完     * 全相同。     *     * @param &lt;T> 数组中对象的类     * @param original 要复制的数组     * @param newLength 要返回的副本的长度     * @return 原始数组的副本，被截断或用null填充以获取指定的长度     * @throws NegativeArraySizeException 如果 &lt;tt>newLength&lt;/tt> 为负     * @throws NullPointerException- 如果&lt;tt>原始&lt;/ tt>为null     * @since 1.6     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">copyOf</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> newLength<span class="token punctuation">,</span> original<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 复制指定的数组，截断或填充为空（如果需要），以便副本具有指定的长度。     * 对于在原始数组和副本中均有效的所有索引，两个数组将包含相同的值。     * 对于副本中有效但原始索引无效的任何索引，副本将包含&lt;tt> null &lt;/ tt>。     * 当且仅当指定长度大于原始数组的长度时，此类索引才会存在。 所得数组属于&lt;tt> newType &lt;/ tt>类。     *     * @param &lt;U> 原始数组中对象的类     * @param &lt;T> 返回数组中对象的类     * @param original 要复制的数组     * @param newLength 要返回的副本的长度     * @param newType 要返回的副本的类别     * @return 原始数组的副本，被截断或用null填充以获取指定的长度     * @throws NegativeArraySizeException 如果 &lt;tt>newLength&lt;/tt> 是为负的     * @throws NullPointerException 如果 &lt;tt>original&lt;/tt> 是 null     * @throws ArrayStoreException 如果从&lt;tt>original&lt;/tt>复制的元素不是可以存储在&lt;tt>newType&lt;/tt>类数组中的运行时类型     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span>U<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span>U<span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> newType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>        T<span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span>newType <span class="token operator">==</span> <span class="token punctuation">(</span>Object<span class="token punctuation">)</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            <span class="token operator">?</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>newLength<span class="token punctuation">]</span>            <span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>newType<span class="token punctuation">.</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                         Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span>length<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> copy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从指定的源数组（从指定位置开始）复制数组到目标数组的指定位置。     * 数组组件的子序列从 &lt;code>src&lt;/code> 引用的源数组复制到 &lt;code>dest&lt;/code> 引用的目标数组。     * 复制的组件数等于 &lt;code>length&lt;/code> 参数。     * 将源数组中位置 &lt;code>srcPos&lt;/code> 到 &lt;code>srcPos + length-1&lt;/code> 的组件复制到位置 &lt;code>destPos&lt;/code> 到     * &lt;code>destPos + length-1的组件&lt;/code> 分别为目标数组。     * &lt;p>     * 如果&lt;code> src &lt;/ code>和&lt;code> dest &lt;/ code>参数引用相同的数组对象，则将执行复制，     * 就好像位置&lt;code> srcPos &lt;/ code>到&lt;code>的组件一样 首先将srcPos + length-1 &lt;/ code>复制到具有&lt;code>      * length &lt;/ code>组件的临时数组中，然后通过&lt;code>将临时数组的内容复制到     * &lt;code> destPos &lt;/ code>中 目标数组的destPos + length-1 &lt;/ code>。     * &lt;p>     * 如果&lt;code> dest &lt;/ code>为&lt;code> null &lt;/ code>，则抛出&lt;code> NullPointerException &lt;/ code>。     * &lt;p>     * 如果&lt;code> src &lt;/ code>为&lt;code> null &lt;/ code>，则将引发&lt;code> NullPointerException &lt;/ code>，并且不会修改目标数组。     * &lt;p>     * 否则，如果满足以下任一条件，则将抛出&lt;code> ArrayStoreException &lt;/ code>，并且不会修改目标：     * &lt;ul>     * &lt;li> &lt;code> src &lt;/ code>参数引用的对象不是数组。     * &lt;li> &lt;code> dest &lt;/ code>参数引用的对象不是数组。     * &lt;li> &lt;code> src &lt;/ code>参数和&lt;code> dest &lt;/ code>参数引用其组件类型为不同原始类型的数组     * &lt;li> &lt;code> src &lt;/ code>参数引用具有原始组件类型的数组，而&lt;code> dest &lt;/ code>参数引用具有引用组件类型的数组。     * &lt;li> &lt;code> src &lt;/ code>参数引用具有引用组件类型的数组，而&lt;code> dest &lt;/ code>参数引用具有原始组件类型的数组。     * &lt;/ul>     * &lt;p>     * 否则，如果满足以下任一条件，则会抛出&lt;code> IndexOutOfBoundsException &lt;/ code>，并且不会修改目标：     * &lt;ul>     * &lt;li> &lt;code> srcPos &lt;/ code>参数为负。     * &lt;li> &lt;code> destPos &lt;/ code>参数为负。     * &lt;li> &lt;code> length &lt;/ code>参数为负。     * &lt;li> &lt;code> srcPos + length &lt;/ code>大于源数组的长度&lt;code> src.length &lt;/ code>。     * &lt;li> &lt;code> destPos + length &lt;/ code>大于目标数组的长度&lt;code> dest.length &lt;/ code>。     * &lt;/ul>     * &lt;p>     * 否则，如果从位置&lt;code> srcPos &lt;/ code>到&lt;code> srcPos + length-1 &lt;/ code>的源数组的任何实际组件     * 都无法通过赋值转换转换为目标数组的组件类型，则&lt; 抛出code> ArrayStoreException &lt;/ code>。 在这种     * 情况下，让&lt;b> &lt;i> k &lt;/ i> &lt;/ b>是小于长度的最小非负整数，这样&lt;code> src [srcPos + &lt;/ code> &lt;i> k &lt;/ i>     *  &lt;code >] &lt;/ code>不能转换为目标数组的组件类型； 当引发异常时，从位置&lt;code> srcPos &lt;/ code>到     * &lt;code> srcPos + &lt;/ code> &lt;i> k &lt;/ i> &lt;code> -1 &lt;/ code>的源数组组件将已经被复制 到目标数组位置     * &lt;code> destPos &lt;/ code>到&lt;code> destPos + &lt;/ code> &lt;i> k &lt;/ I> &lt;code> -1 &lt;/ code>，并且目标数组的     * 其他位置都不会被修改 。 （由于已经逐项列出了限制，因此本段仅适用于两个数组都具有引用类型的组件类型的情况。）     *     * @param      src      源数组。     * @param      srcPos   源数组中的起始位置。     * @param      dest     目标数组。     * @param      destPos  目标数据中的起始位置。     * @param      length   要复制的数组元素的数量。     * @exception  IndexOutOfBoundsException 如果复制将导致超出数组范围的数据访问。     * @exception  ArrayStoreException 如果由于类型不匹配而无法将&lt;code> src &lt;/ code>数组中的元素存储到&lt;code> dest &lt;/ code>数组中。     * @exception  如果&lt;code> src &lt;/ code>或&lt;code> dest &lt;/ code>为&lt;code> null &lt;/ code>，则为 NullPointerException。     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>Object src<span class="token punctuation">,</span>  <span class="token keyword">int</span>  srcPos<span class="token punctuation">,</span>                                        Object dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>                                        <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>通过上面代码可以看到 <code>copyOf()</code> 内部调用了 <code>System.arraycopy()</code>，这个方法是数组扩容的核心所在，是一个 <code>native</code> 方法。</p><p>他俩的区别在用法上 <code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h3 id="ArrayList-的-Fail-Fast"><a href="#ArrayList-的-Fail-Fast" class="headerlink" title="ArrayList 的 Fail-Fast"></a>ArrayList 的 Fail-Fast</h3><p><code>Fail-Fast</code> 是 Java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 <code>Fail-Fast</code> 机制。原因是迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <code>modCount</code> 变量。集合在被遍历期间如果内容发生变化，就会改变 <code>modCount</code> 的值。<br>每当迭代器使用 <code>hashNext()/next()</code> 遍历下一个元素之前，都会检测 <code>modCount</code> 变量是否为 <code>expectedmodCount</code> 值，是的话就返回遍历；否则抛出异常，终止遍历。<br>解决办法是，使用 <code>CopyOnWriteArrayList</code> 来替换 ArrayList 或者使用 <code>Collections.synchronizedList(list)</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler 解析</title>
      <link href="/handler/"/>
      <url>/handler/</url>
      
        <content type="html"><![CDATA[<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><code>Handler</code> 主要有俩个用途首先是可以用来定时处理或者分发消息，其次可以在其他线程中添加操作。当在子线程中进行耗时操作后需要更新 UI 时可以通过 <code>Handler</code> 将有关 UI 的操作切换到主线程中执行。</p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件:"></a>必要条件:</h3><ul><li>Message（消息）：需要被传递的消息其中包含了消息 ID，消息处理对象以及处理的数据等，由 <code>MessageQueue</code> 存储，最终由 <code>Handler</code> 处理。</li><li>MessageQueue（消息队列）：将 <code>Handler</code> 发送过来的消息存入一个消息队列中来依次执行，内部通过单链表的数据结构来维护消息列表。</li><li>Handler（处理者）：负责 <code>Message</code> 的发送及处理。通过 <code>Handler.sendMessage()</code> 向消息池发送各种消息事件,通过 <code>Handler.handleMessage()</code> 处理相应的消息事件。</li><li>Looper（消息泵）：通过 <code>Looper.loop()</code> 不断地从 <code>MessageQueue</code> 中抽取 <code>Message</code>，按分发机制将消息分发给目标处理者。<code>Looper</code> 不断从 <code>MessageQueue</code> 中获取消息并将之传递给消息处理者（即是消息发送者 <code>Handler</code> 本身）进行处理。</li></ul><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ul><li><code>Handler.sendMessage()</code> 发送消息时，会通过 <code>MessageQueue.enqueueMessage()</code> 向 <code>MessageQueue</code> 中添加一条消息。</li><li>通过 <code>Looper.loop()</code> 开启循环后，不断轮询调用 <code>MessageQueue.next()</code>；</li><li>调用目标 <code>Handler.dispatchMessage()</code> 去传递消息，目标 <code>Handler</code> 收到消息后调用 <code>Handler.handlerMessage()</code> 处理消息。</li></ul><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p><code>MessageQueue</code> 用来执行插入与读取的操作，使用 <code>enqueueMessage()</code> 往消息队列中插入一条消息， <code>next()</code> 的作用是从消息队列中取出一条消息并将其从消息队列中移除。其内部是使用一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。</p><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p><code>Looper</code> 类主要用于一个线程循环获取消息队列中的消息。<code>Looper</code> 的作用主要是负责管理消息队列，负责消息的出列和入列操作。</p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p><code>android.os.Message</code> 是定义一个 <code>Message</code> 包含必要的描述和属性数据，此对象可以被发送给 <code>android.os.Handler</code> 并关联到一个 <code>handler</code> 处理其中的消息。 <code>Message</code> 对象不是直接 <code>new</code> 出来的，只要调用 <code>handler</code> 中的 <code>obtainMessage</code> 方法来直接获得 <code>Message</code> 对象。<br>它的属性字段分别有：<code>arg1</code>、<code>arg2</code>、<code>what</code>、<code>obj</code>、<code>replyTo</code> 等，<code>arg1</code> 和 <code>arg2</code> 是用来存放整型数据的，<code>what</code> 是用来保存消息标示的<br><code>obj</code> 是 <code>Object</code> 类型的任意对象，<code>replyTo</code> 是消息管理器。</p><p>以上是 <code>Handler</code> 工作机制接下来看一下其内部的代码实现。</p><h3 id="Handler-内部实现"><a href="#Handler-内部实现" class="headerlink" title="Handler 内部实现"></a>Handler 内部实现</h3><h5 id="发送消息的形式"><a href="#发送消息的形式" class="headerlink" title="发送消息的形式"></a>发送消息的形式</h5><p>Handler 发送消息的形式主要有以下几种形式，其最终调用的都是 <code>sendMessageAtTime()</code> 方法</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span>  <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>delayMillis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            delayMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   </code></pre><p>可以看到 <code>sendMessageAtTime()</code> 方法中需要一个已初始化的 MessageQueue 类型的全局变量 <code>mQueue</code>，否则程序无法继续走下去</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            RuntimeException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" sendMessageAtTime() called with no mQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token string">"Looper"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>而 <code>mQueue</code> 变量是在构造函数中进行初始化的，且 <code>mQueue</code> 是成员常量，这说明 Handler 与 MessageQueue 是一一对应的关系，不可更改。</p><p>如果构造函数没有传入 <code>Looper</code> 参数，则会默认使用当前线程关联的 <code>Looper</code> 对象，<code>mQueue</code> 需要依赖于从 <code>Looper</code> 对象中获取，如果 <code>Looper</code> 对象为 <code>null</code> ，则会直接抛出异常，且从异常信息 <code>Can&#39;t create handler inside thread that has not called Looper.prepare()</code> 中可以看到，在向 Handler 发送消息前，需要先调用 <code>Looper.prepare()</code></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ···        mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                <span class="token string">"Can't create handler inside thread that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>        mCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>        mAsynchronous <span class="token operator">=</span> async<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="handler-sendMessage-msg"><a href="#handler-sendMessage-msg" class="headerlink" title="handler.sendMessage(msg)"></a>handler.sendMessage(msg)</h5><p>在 <code>enqueueMessage(queue, msg, uptimeMillis)</code> 这个方法中可以看到 <code>msg.target</code> 就是 Handler 本身，而这里的 <code>queue</code> 是 Handler 内部维护 Looper 所关联的 MessageQueue 对象。</p><pre class=" language-java"><code class="language-java">    handler<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            RuntimeException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" sendMessageAtTime() called with no mQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token string">"Looper"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>MessageQueue queue<span class="token punctuation">,</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        msg<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mAsynchronous<span class="token punctuation">)</span> <span class="token punctuation">{</span>            msg<span class="token punctuation">.</span><span class="token function">setAsynchronous</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">enqueueMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="Looper轮训操作"><a href="#Looper轮训操作" class="headerlink" title="Looper轮训操作"></a>Looper轮训操作</h5><p>在Looper 类中，可以看到，<code>myLooper()</code> 方法是从 <code>sThreadLocal</code> 对象中获取 Looper 对象的，<code>sThreadLocal</code> 对象又是通过 <code>prepare(boolean)</code> 来进行赋值的，且该方法只允许调用一次，一个线程只能创建一个 Looper 对象，否则将抛出异常。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Looper<span class="token operator">></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>Looper<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token annotation punctuation">@Nullable</span> Looper <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>此处除了因为 <code>prepare(boolean)</code> 多次调用会抛出异常导致无法关联多个 Looper 外，Looper 类的构造函数也是私有的，且在构造函数中还初始化了一个线程常量 <code>mThread</code>，这都说明了 Looper 只能关联到一个线程，且关联之后不能改变。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">final</span> Thread mThread<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// quitAllowed 表示线程是否可以退出主线程默认是不可以退出的，子线程是可以退出的</span>    <span class="token keyword">private</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>        mThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>查找该方法的所有引用，可以发现在 <code>Looper</code> 类中有如下方法，从名字来看，可以猜测该方法是由主线程来调用的，查找其引用。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Looper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainLooper <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"The main Looper has already been prepared."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            sMainLooper <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>在 <code>ActivityThread</code> 类的 <code>main()</code> 方法中可以看到在主线程做了 <code>Handler</code> 的初始化操作所以在主线程中可以直接使用 <code>Handler</code>。如果是在子线程中创建 <code>Handler</code> 则需要手动来调用 <code>Looper.prepare()</code> 方法。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ···        Looper<span class="token punctuation">.</span><span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ActivityThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActivityThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainThreadHandler <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sMainThreadHandler <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMessageLogging</span><span class="token punctuation">(</span><span class="token keyword">new</span>                    <span class="token class-name">LogPrinter</span><span class="token punctuation">(</span>Log<span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span> <span class="token string">"ActivityThread"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// End of event ActivityThreadMain.</span>        Trace<span class="token punctuation">.</span><span class="token function">traceEnd</span><span class="token punctuation">(</span>Trace<span class="token punctuation">.</span>TRACE_TAG_ACTIVITY_MANAGER<span class="token punctuation">)</span><span class="token punctuation">;</span>        Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Main thread loop unexpectedly exited"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="MessageQueue-消息队列"><a href="#MessageQueue-消息队列" class="headerlink" title="MessageQueue 消息队列"></a>MessageQueue 消息队列</h5><p><code>mQueue</code> 在 <code>Looper</code> 类的构造函数中初始化的，并且 <code>mQueue</code> 是 <code>Looper</code> 类的成员常量，这说明 <code>Looper</code> 与 <code>MessageQueue</code> 是一一对应的关系。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>        mThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>sendMessageAtTime()</code> 方法中在处理 <code>Message</code> 时，最终调用的是 <code>enqueueMessage()</code> 方法，需要注意的是 <code>msg.target = this</code> 这句代码，<code>target</code> 对象指向了发送消息的主体，即 <code>Handler</code> 对象本身，即由 Handler 对象发给 <code>MessageQueue</code> 的消息最后还是要交由 <code>Handler</code> 对象本身来处理。<br>因为存在多个线程往同一个 <code>Loop</code> 线程的 <code>MessageQueue</code> 中插入消息的可能，所以 <code>enqueueMessage()</code> 内部需要进行同步。可以看出 <code>MessageQueue</code> 内部是以链表的结构来存储 <code>Message</code> 的，其插入顺序是由 <code>Message</code> 的延时时间的长短来做决定的。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            RuntimeException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" sendMessageAtTime() called with no mQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token string">"Looper"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>MessageQueue queue<span class="token punctuation">,</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//target 对象指向的也是发送消息的主体，即 Handler 对象</span>        <span class="token comment" spellcheck="true">//即由 Handler 对象发给 MessageQueue 的消息最后还是要交由 Handler 对象本身来处理</span>        msg<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mAsynchronous<span class="token punctuation">)</span> <span class="token punctuation">{</span>            msg<span class="token punctuation">.</span><span class="token function">setAsynchronous</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">enqueueMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="MessageQueue-传递消息给-Handler"><a href="#MessageQueue-传递消息给-Handler" class="headerlink" title="MessageQueue 传递消息给 Handler"></a>MessageQueue 传递消息给 Handler</h5><p><code>mMessages</code> 代表的是消息队列中的第一条消息，如果 <code>mMessages</code> 为空，说明消息队列是空的，或者 <code>mMessages</code> 的触发时间要比新消息晚，则将新消息插入消息队列的头部。如果 <code>mMessages</code> 不为空，则寻找消息列队中第一条触发时间比新消息晚的非空消息，并将新消息插到该消息前面。<br>一个按照处理时间进行排序的消息队列就完成了，后边要做的就是从消息队列中依次取出消息进行处理。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> when<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//Message 必须有处理者</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>target <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Message must have a target."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">isInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>msg <span class="token operator">+</span> <span class="token string">" This message is already in use."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mQuitting<span class="token punctuation">)</span> <span class="token punctuation">{</span>                IllegalStateException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>                        msg<span class="token punctuation">.</span>target <span class="token operator">+</span> <span class="token string">" sending message to a Handler on a dead thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                msg<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            msg<span class="token punctuation">.</span><span class="token function">markInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            msg<span class="token punctuation">.</span>when <span class="token operator">=</span> when<span class="token punctuation">;</span>            Message p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>            <span class="token keyword">boolean</span> needWake<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果消息队列是空的或者队列中第一条的消息的触发时间要比新消息长，则将新消息作为链表头部</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> when <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// New head, wake up the event queue if blocked.</span>                msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>                mMessages <span class="token operator">=</span> msg<span class="token punctuation">;</span>                needWake <span class="token operator">=</span> mBlocked<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Inserted within the middle of the queue.  Usually we don't have to wake</span>                <span class="token comment" spellcheck="true">// up the event queue unless there is a barrier at the head of the queue</span>                <span class="token comment" spellcheck="true">// and the message is the earliest asynchronous message in the queue.</span>                needWake <span class="token operator">=</span> mBlocked <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>target <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Message prev<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//寻找消息列队中第一条触发时间比新消息晚的消息，并将新消息插到该消息前面</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    prev <span class="token operator">=</span> p<span class="token punctuation">;</span>                    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        needWake <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// invariant: p == prev.next</span>                prev<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// We can assume mPtr != 0 because mQuitting is false.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">nativeWake</span><span class="token punctuation">(</span>mPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="MessageQueue-读取-Message-回调给-Handler"><a href="#MessageQueue-读取-Message-回调给-Handler" class="headerlink" title="MessageQueue 读取 Message 回调给 Handler"></a>MessageQueue 读取 Message 回调给 Handler</h5><p>再看下 <code>MessageQueue</code> 是如何读取 <code>Message</code> 并回调给 <code>Handler</code> 的,在 <code>MessageQueue</code> 中消息的读取其实是通过内部的 <code>next()</code> 方法进行的，<br><code>next()</code> 方法是一个无限循环的方法，如果消息队列中没有消息，则该方法会一直阻塞，当有新消息来的时候 <code>next()</code> 方法会返回这条消息并将其从单链表中删除。</p><pre class=" language-java"><code class="language-java">    Message <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Return here if the message loop has already quit and been disposed.</span>        <span class="token comment" spellcheck="true">// This can happen if the application tries to restart a looper after quit</span>        <span class="token comment" spellcheck="true">// which is not supported.</span>        <span class="token keyword">final</span> <span class="token keyword">long</span> ptr <span class="token operator">=</span> mPtr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> pendingIdleHandlerCount <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -1 only during first iteration</span>        <span class="token keyword">int</span> nextPollTimeoutMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextPollTimeoutMillis <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Binder<span class="token punctuation">.</span><span class="token function">flushPendingCommands</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">nativePollOnce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> nextPollTimeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Try to retrieve the next message.  Return if found.</span>                <span class="token keyword">final</span> <span class="token keyword">long</span> now <span class="token operator">=</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Message prevMsg <span class="token operator">=</span> null<span class="token punctuation">;</span>                Message msg <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span>target <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        prevMsg <span class="token operator">=</span> msg<span class="token punctuation">;</span>                        msg <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>msg<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&lt;</span> msg<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>                        nextPollTimeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// Got a message.</span>                        mBlocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>prevMsg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            prevMsg<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            mMessages <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        msg<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>DEBUG<span class="token punctuation">)</span> Log<span class="token punctuation">.</span><span class="token function">v</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Returning message: "</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                        msg<span class="token punctuation">.</span><span class="token function">markInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> msg<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// No more messages.</span>                    nextPollTimeoutMillis <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// Process the quit message now that all pending messages have been handled.</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mQuitting<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// If first time idle, then get the number of idlers to run.</span>                <span class="token comment" spellcheck="true">// Idle handles only run if the queue is empty or if the first message</span>                <span class="token comment" spellcheck="true">// in the queue (possibly a barrier) is due to be handled in the future.</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingIdleHandlerCount <span class="token operator">&lt;</span> <span class="token number">0</span>                        <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mMessages <span class="token operator">==</span> null <span class="token operator">||</span> now <span class="token operator">&lt;</span> mMessages<span class="token punctuation">.</span>when<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pendingIdleHandlerCount <span class="token operator">=</span> mIdleHandlers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingIdleHandlerCount <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// No idle handlers to run.  Loop and wait some more.</span>                    mBlocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mPendingIdleHandlers <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    mPendingIdleHandlers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdleHandler</span><span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pendingIdleHandlerCount<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                mPendingIdleHandlers <span class="token operator">=</span> mIdleHandlers<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>mPendingIdleHandlers<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Run the idle handlers.</span>            <span class="token comment" spellcheck="true">// We only ever reach this code block during the first iteration.</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pendingIdleHandlerCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> IdleHandler idler <span class="token operator">=</span> mPendingIdleHandlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                mPendingIdleHandlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// release the reference to the handler</span>                <span class="token keyword">boolean</span> keep <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    keep <span class="token operator">=</span> idler<span class="token punctuation">.</span><span class="token function">queueIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Log<span class="token punctuation">.</span><span class="token function">wtf</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"IdleHandler threw exception"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>keep<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        mIdleHandlers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>idler<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Reset the idle handler count to 0 so we do not run them again.</span>            pendingIdleHandlerCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// While calling an idle handler, a new message could have been delivered</span>            <span class="token comment" spellcheck="true">// so go back and look again for a pending message without waiting.</span>            nextPollTimeoutMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><code>next()</code> 方法又是通过 <code>Looper</code> 类的 <code>loop()</code> 方法来循环调用的，而 <code>loop()</code> 方法也是一个无限循环，唯一跳出循环的条件就是 <code>queue.next()</code> 方法返回为 <code>null</code> ，细心的读者可能已经发现了，<code>loop()</code> 就是在 <code>ActivityThread</code> 的 <code>main()</code> 函数中调用的<br>因为 <code>next()</code> 方法是一个阻塞操作，所以当没有消息也会导致 <code>loop()</code> 方法一直阻塞着，而当 <code>MessageQueue</code> 中有了新的消息，<code>Looper</code> 就会及时地处理这条消息并调用 <code>Message.target.dispatchMessage(Message)</code> 方法将消息传回给 <code>Handler</code> 进行处理。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Run the message queue in this thread. Be sure to call     * {@link #quit()} to end the loop.     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Looper me <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>me <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"No Looper; Looper.prepare() wasn't called on this thread."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> MessageQueue queue <span class="token operator">=</span> me<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Make sure the identity of this thread is that of the local process,</span>        <span class="token comment" spellcheck="true">// and keep track of what that identity token actually is.</span>        Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">long</span> ident <span class="token operator">=</span> Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Message msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// might block</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// No message indicates that the message queue is quitting.</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// This must be in a local variable, in case a UI event sets the logger</span>            <span class="token keyword">final</span> Printer logging <span class="token operator">=</span> me<span class="token punctuation">.</span>mLogging<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logging <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logging<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">">>>>> Dispatching to "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>target <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span>                        msg<span class="token punctuation">.</span>callback <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> slowDispatchThresholdMs <span class="token operator">=</span> me<span class="token punctuation">.</span>mSlowDispatchThresholdMs<span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> traceTag <span class="token operator">=</span> me<span class="token punctuation">.</span>mTraceTag<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>traceTag <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> Trace<span class="token punctuation">.</span><span class="token function">isTagEnabled</span><span class="token punctuation">(</span>traceTag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Trace<span class="token punctuation">.</span><span class="token function">traceBegin</span><span class="token punctuation">(</span>traceTag<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getTraceName</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token punctuation">(</span>slowDispatchThresholdMs <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> end<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                end <span class="token operator">=</span> <span class="token punctuation">(</span>slowDispatchThresholdMs <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>traceTag <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Trace<span class="token punctuation">.</span><span class="token function">traceEnd</span><span class="token punctuation">(</span>traceTag<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slowDispatchThresholdMs <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">long</span> time <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">></span> slowDispatchThresholdMs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Slog<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Dispatch took "</span> <span class="token operator">+</span> time <span class="token operator">+</span> <span class="token string">"ms on "</span>                            <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", h="</span> <span class="token operator">+</span>                            msg<span class="token punctuation">.</span>target <span class="token operator">+</span> <span class="token string">" cb="</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>callback <span class="token operator">+</span> <span class="token string">" msg="</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logging <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logging<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>target <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Make sure that during the course of dispatching the</span>            <span class="token comment" spellcheck="true">// identity of the thread wasn't corrupted.</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> newIdent <span class="token operator">=</span> Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ident <span class="token operator">!=</span> newIdent<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">wtf</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Thread identity changed from 0x"</span>                        <span class="token operator">+</span> Long<span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>ident<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" to 0x"</span>                        <span class="token operator">+</span> Long<span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>newIdent<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" while dispatching to "</span>                        <span class="token operator">+</span> msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span>                        <span class="token operator">+</span> msg<span class="token punctuation">.</span>callback <span class="token operator">+</span> <span class="token string">" what="</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="Handler-接收消息并处理"><a href="#Handler-接收消息并处理" class="headerlink" title="Handler 接收消息并处理"></a>Handler 接收消息并处理</h5><p>Handler 处理消息的方法</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Handle system messages here.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatchMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>callback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleCallback</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mCallback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mCallback<span class="token punctuation">.</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>如果 <code>msg.callback</code> 不为 <code>null</code> ，则调用 <code>callback</code> 对象的 <code>run()</code> 方法，该 <code>callback</code> 实际上就是一个 <code>Runnable</code> 对象，对应的是 <code>Handler</code> 对象的 <code>post()</code> 方法。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleCallback</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        message<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span>  <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Message <span class="token function">getPostMessage</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message m <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">.</span>callback <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">return</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>如果 <code>mCallback</code> 不为 <code>null</code> ，则通过该回调接口来处理消息，如果在初始化 <code>Handler</code> 对象时没有通过构造函数传入 <code>Callback</code> 回调接口，则交由 <code>handleMessage(Message)</code> 方法来处理消息，我们一般也是通过重写 <code>Handler</code> 的 <code>handleMessage(Message)</code> 方法来处理消息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>在创建 <code>Handler</code> 实例时要么为构造函数提供一个 <code>Looper</code> 实例，要么默认使用当前线程关联的 <code>Looper</code> 对象，如果当前线程没有关联的 <code>Looper</code> 对象，则会导致抛出异常。</li><li><code>Looper</code> 与 <code>Thread</code> ，<code>Looper</code> 与 <code>MessageQueue</code> 都是一一对应的关系，在关联后无法更改，但 <code>Handler</code> 与 <code>Looper</code> 可以是多对一的关系。</li><li><code>Handler</code> 能用于更新 UI 有个前提条件：<code>Handler</code> 与主线程关联在了一起。在主线程中初始化的 <code>Handler</code> 会默认与主线程绑定在一起，所以此后在处理 <code>Message</code> 时，<code>handleMessage(Message msg)</code> 方法的所在线程就是主线程，因此 <code>Handler</code> 能用于更新 UI。</li><li>可以创建关联到另一个线程 <code>Looper</code> 的 <code>Handler</code>，只要本线程能够拿到另外一个线程的 <code>Looper</code> 实例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 范型与 Kotlin 范型</title>
      <link href="/java-fan-xing-yu-kotlin-fan-xing/"/>
      <url>/java-fan-xing-yu-kotlin-fan-xing/</url>
      
        <content type="html"><![CDATA[<p>Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常。<br>Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。</p><h3 id="范型的好处"><a href="#范型的好处" class="headerlink" title="范型的好处"></a>范型的好处</h3><ol><li>类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。</li><li>消除了代码中许多的强制类型转换，增强了代码的可读性。</li><li>为较大的优化带来了可能。优化了程序设计，解决了黄色警告线。</li></ol><p>关于范型需要了解<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="noopener">逆变与协变</a>，因为涉及到上下变型关系不了解的话容易绕晕。<br>翻译在解决了类型转换的问题后，发先了继承关系中类型不一致的问题。逆变与协变就是为了解决这种问题，平时开发中也会经常用到。<br>我们在基础的架构时会对数据进行封装或者根据逻辑的层级结构进行封装都会用到。不要害怕。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// Java 协变写法 strong</span>    List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Java 逆变写法</span>    List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Number<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin">    <span class="token comment" spellcheck="true">// Kotlin 协变写法</span>    <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span><span class="token keyword">out</span> Number<span class="token operator">></span> <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Kotlin 逆变写法</span>    <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span><span class="token keyword">in</span> Int<span class="token operator">></span> <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>Number<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>型变（协变和逆变）涉及到集合元素，集合类。协变讲的是两个集合的元素是子类关系，这两个集合也是子类关系，有了子类关系，就可以用多态表示。逆变的关系是反过来的，逆变说得是，两个集合的元素是父类关系，这两个集合却能成为子类关系。</p><h3 id="Kotlin-投影与-Java-通配符-？-差异"><a href="#Kotlin-投影与-Java-通配符-？-差异" class="headerlink" title="Kotlin * 投影与 Java 通配符 ？ 差异"></a>Kotlin * 投影与 Java 通配符 ？ 差异</h3><pre class=" language-kotlin"><code class="language-kotlin">    <span class="token comment" spellcheck="true">// kotlin * 投影</span>    <span class="token keyword">val</span> clazz<span class="token operator">:</span>Class<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">=</span> List<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java</code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// Java ? 通配符</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>摘录一段 Kotlin 官方对 <code>*</code> 说明:</p><ul><li>对于 <code>Foo &lt;out T&gt;</code>，其中 T 是一个具有上界 TUpper 的协变类型参数，<code>Foo &lt;*&gt;</code> 等价于 <code>Foo &lt;out TUpper&gt;</code>。 这意味着当 T 未知时，你可以安全地从 <code>Foo &lt;*&gt;</code> 读取 TUpper 的值。</li><li>对于 <code>Foo &lt;in T&gt;</code>，其中 T 是一个逆变类型参数，<code>Foo &lt;*&gt;</code> 等价于 <code>Foo &lt;in Nothing&gt;</code>。 这意味着当 T 未知时，没有什么可以以安全的方式写入 <code>Foo &lt;*&gt;</code>。</li><li>对于 <code>Foo &lt;T&gt;</code>，其中 T 是一个具有上界 TUpper 的不型变类型参数，<code>Foo&lt;*&gt;</code> 对于读取值时等价于 <code>Foo&lt;out TUpper&gt;</code> 而对于写值时等价于 <code>Foo&lt;in Nothing&gt;</code>。</li></ul><p><code>*</code> 投影不适用与函数及变量的类型范型参数，不能作为弗雷多额范型参数传入。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin 与 Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin 与 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创业团队经历与总结</title>
      <link href="/ge-ren-zong-jie/"/>
      <url>/ge-ren-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>在这里我总结一下工作中与生活中遇到的事情。</p><p>在2019年7月入职一家创业团队，在入职前已经做好最累的打算实际上我做的打算与遇到的差距还不小。工作是 996 的性质，但是实际上大多数下班时间是在10点或这更晚一些。回到住的地方大概时间是在11点左右。<br>起初还能保持每晚1个小时的学习随着时间变长，就无法再持续下去。</p><p>每周1-2次的版本迭代与 Bug 修复加剧了精力与激情的消耗。成为了一个不折不扣的机器不会思考生活每天只有面临的各种问题。没过试用期的时候曾想着要不要结束，但是我觉得困难是会过去的不能向困难低头。</p><p>团队没有规范的流程，大多数开发的时候会临时加入其他的需求或者要发版上线的时候加新的需求。一开始我是拒绝的因为我不能保证不会出问题没有专业的测试，长期以往就失去了对生活与工作的希望一点都不夸张。</p><p>致使我最终决定离开团队的原因是，我感受不到我是一个员工，更多的是我是这个团队的写代码机器，负责人要求技术晚上不能关机不能静音随时在线（这里我吐槽一下，负责人平时晚上到公司开始他的工作直到半夜还会在微信群中提出问题），这让我感到痛苦我本身就有睡眠质量差的问题。有一次的版本迭代中我很累坚持不住也被强行要求发版上线一直工作到凌晨。<br>甚至希望周日也在工作，创业团队艰难我是可以理解的，但是这样让我觉得团队需要的是一个机器而不是一个伙伴，我也没有说什么在最后一次迭代后提出了离职。不合适就没必要继续留下去，对双方来说都是损失。</p><p>另一位同事在年前休息的时候接到电话说年后不需要到公司了。具体原因我不清楚，团队的结构是后台1人，iOS 1人 Android 1人，被辞退的同事被找来没有过试用期他是新招的后台。除了我，技术的另外俩位同事是创始人。</p><p>上面是我的一些吐槽。接下来我说一下我的个人总结，如果选择创业团队一定要看负责人，负责人如果没有经验那么多半是无法快速的带领团队走向目标，因为缺少经验意味着要一点点去尝试，负责人的人品与格局也很重要，这决定身边一起奋斗是伙伴还是机器。<br>要时刻保持学习，哪怕有一点点的时间也要深入的学习，因为这是对自己的负责，即便连续工作十几个小时，因为投资自己才能提高生存的几率，要思考，在繁重的工作中思维会有一个潜意识想法，我要修复这个问题因为还有很多问题和功能要做，有了这个想法就会变成一种为了写功能而写功能，没有思考的能力。</p><p>最后我没有对团队的抱怨的心态，感谢团队的知遇之恩，因为我离开后始终会有合适的朋友继续在那个岗位工作，也反思自己因为身体的疲累而放弃学习，放弃自我的提升。也意识到不管什么时候要思考，即便自己的提议不被接受也要保持自己的思考，因为时间久了就不会思考了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConstraintLayout 属性简介</title>
      <link href="/constraintlayout/"/>
      <url>/constraintlayout/</url>
      
        <content type="html"><![CDATA[<p>在日常开发中会遇到多种布局结构，导致 xml 层级嵌套过多，xml 又是 IO 操作，在 vSync 信号量通知界面绘制刷新时可能会造成卡顿当然原因会有多种，这里做一个例子。</p><p>使用 ConstraintLayout 可以有效的避免层级嵌套过深问题，日常开发中一个层级就可以搞定之前多层级嵌套的布局。它的众多属性非常的灵活简单易用。</p><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>相对定位属性的特点是 constraint 后边的方向是指当前控件的位置，下划线后的方向是指定控件的位置。</p><ul><li>layout_constraintLeft_toLeftOf</li><li>layout_constraintLeft_toRightOf</li><li>layout_constraintRight_toLeftOf</li><li>layout_constraintRight_toRightOf</li><li>layout_constraintTop_toTopOf</li><li>layout_constraintTop_toBottomOf</li><li>layout_constraintBottom_toTopOf</li><li>layout_constraintBottom_toBottomOf</li><li>layout_constraintBaseline_toBaselineOf</li><li>layout_constraintStart_toEndOf</li><li>layout_constraintStart_toStartOf</li><li>layout_constraintEnd_toStartOf</li><li>layout_constraintEnd_toEndOf</li></ul><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- buttonB 设置了约束属性将自己的左边设置在 buttonA 的右边  --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonA<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>         <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonB<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintLeft_toRightOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonA<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h2 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h2><ul><li>android:layout_marginStart</li><li>android:layout_marginEnd</li><li>android:layout_marginLeft</li><li>android:layout_marginTop</li><li>android:layout_marginRight</li><li>android:layout_marginBottom</li></ul><p>上面的属性是常规设置边距，使用方法和 LinearLayout 及 RelateLayout 无异，下面的属性就比较有趣了，在布局中会用到 <code>GONE</code>，当使用这个属性后有一个问题当该控件再次显示的时候会触发绘制，就会有一个屏幕跳动的问题，当使用一下属性时可以设置在 <code>GONE</code> 状态下与指定目标的位置，在显示的时候可以避免这种问题。</p><ul><li>layout_goneMarginStart</li><li>layout_goneMarginEnd</li><li>layout_goneMarginLeft</li><li>layout_goneMarginTop</li><li>layout_goneMarginRight</li><li>layout_goneMarginBottom</li></ul><h2 id="居中定位"><a href="#居中定位" class="headerlink" title="居中定位"></a>居中定位</h2><p>这俩个属性可以更改属性偏移位置，视图同时设置 <code>layout_constraintStart_toStartOf</code> 及 <code>layout_constraintEnd_toEndOf</code> 会默认为居中也就是 50%，通过以下俩个属性可以更改居中的位置。</p><ul><li>layout_constraintHorizontal_bias</li><li>layout_constraintVertical_bias</li></ul><h2 id="圆形定位"><a href="#圆形定位" class="headerlink" title="圆形定位"></a>圆形定位</h2><ul><li>layout_constraintCircle : 引用另一个小部件ID</li><li>layout_constraintCircleRadius : 到另一个小部件中心的距离</li><li>layout_constraintCircleAngle : 小部件应处于的角度（以度为单位，从0到360）</li></ul><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonA<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>         <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonB<span class="token punctuation">"</span></span> <span class="token attr-name">...</span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintCircle</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonA<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintCircleRadius</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintCircleAngle</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>45<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h2 id="尺寸限制"><a href="#尺寸限制" class="headerlink" title="尺寸限制"></a>尺寸限制</h2><h3 id="MATCH-CONSTRAINT尺寸"><a href="#MATCH-CONSTRAINT尺寸" class="headerlink" title="MATCH_CONSTRAINT尺寸"></a>MATCH_CONSTRAINT尺寸</h3><p>当尺寸设置为时 MATCH_CONSTRAINT，默认行为是使结果尺寸占用所有可用空间。可以使用其他几个修饰符：</p><ul><li>layout_constraintWidth_min和layout_constraintHeight_min：将为此尺寸设置最小尺寸</li><li>layout_constraintWidth_max和layout_constraintHeight_max：将为此尺寸设置最大尺寸</li><li>layout_constraintWidth_percent和layout_constraintHeight_percent：将此尺寸的尺寸设置为父尺寸的百分比</li></ul><h3 id="最小与最大"><a href="#最小与最大" class="headerlink" title="最小与最大"></a>最小与最大</h3><ul><li>尺寸应设置为 MATCH_CONSTRAINT（0dp）</li><li>默认值应设置为百分比app:layout_constraintWidth_default=”percent” 或 app:layout_constraintHeight_default=”percent”</li><li>然后将 layout_constraintWidth_percent 或 layout_constraintHeight_percent 属性设置为介于 0 和 1 之间的值<br>比</li></ul><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--浮点值，表示宽度和高度之间的比率形式为“宽度：高度”的比率 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>         <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintDimensionRatio</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1:1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>以上内容是摘录至文档部分内容。在使用中如果以某一个控件为位置主导，那该控件要设置四个约束属性，不然未设置的那个属性会出现变形或移位的问题，当控件 A 底部设置在 控件 B 顶部时，那么控件 B 也要设置顶部到控件 A 的底部，开环与闭环原则。</p><p>match 这个可以用 <code>0dp</code> 代替并设置控件的约束位置，如果使用 match 会有超出可见范围的问题。</p><p>有另一种更简单的方法设置就是使用 Android Studio 的 <code>Design</code> 模式可以通过点击的方式进行设置各种属性的大概位置，精确的位置需要手动调整。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 接口与 Java8 新特性接口</title>
      <link href="/kotlin-java8/"/>
      <url>/kotlin-java8/</url>
      
        <content type="html"><![CDATA[<p>在看一本关于高性能编程的时候发现 Java8 中关于接口的新特性的介绍，这个特性是真的棒，解决了一个接口中有多个方法，但并不想实现该接口的类都去实现所有的方法，简单的说就是在类需要的情况再去重写接口。所以有了以下的特性出现。</p><h2 id="接口增强"><a href="#接口增强" class="headerlink" title="接口增强"></a>接口增强</h2><p>在 Java8 的中接口特性中增加以下俩种特性:</p><ul><li><p>在接口中可以使用 default 关键字修饰默认方法或扩展方法，抽象方法因为其特性的原因无法使用</p></li><li><p>接口可以使用 static 声明为静态方法，可以通过类直接调用</p><p>   Android Studio 中使用 Java8 需要在模块中的 build.gradle 中配置指定的版 Java 版本，当然使用 Kotlin 为开发语言的话需要为 Kotlin 指定 Jvm 版本，因为 Kotlin 使用的是 Jvm 1.6 那么下面就来展示他们的配置方法：</p><pre class=" language-groovy"><code class="language-groovy">        android <span class="token punctuation">{</span>            defaultConfig <span class="token punctuation">{</span>                <span class="token punctuation">...</span>                  kotlinOptions <span class="token punctuation">{</span>                    jvmTarget <span class="token operator">=</span> <span class="token string">'1.8'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            compileOptions <span class="token punctuation">{</span>                sourceCompatibility JavaVersion<span class="token operator">.</span>VERSION_1_8                targetCompatibility JavaVersion<span class="token operator">.</span>VERSION_1_8            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>   经过以上的配置就可以使用 Java8 的新特性了</p></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h3><pre class=" language-java"><code class="language-java">    puclic <span class="token keyword">interface</span> <span class="token class-name">onTest</span><span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">onTestStandardMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">onTestDefaultMethond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 默认的逻辑</span>        <span class="token punctuation">}</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">onTestStaticMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 默认的逻辑</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token keyword">implements</span> <span class="token class-name">onTest</span><span class="token punctuation">{</span>       <span class="token annotation punctuation">@Override</span>       <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 通过类名调用的接口</span>        onTest<span class="token punctuation">.</span><span class="token function">onTestStaticMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过对象的形式调用 代码只用来举例说明</span>        <span class="token keyword">new</span> <span class="token class-name">TestActivity<span class="token punctuation">.</span>onTestStandardMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">new</span> <span class="token class-name">TestActivity<span class="token punctuation">.</span>onTestDefaultMethond</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onTestStandardMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 必须实现</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onTestDefaultMethond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 可以选择性实现</span>    <span class="token punctuation">}</span></code></pre><p>上面的代码是展示如何使用，如果对具体的细节想了解的更清楚可以查看官方的<a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">文档</a></p><p>可能有朋友好奇我为什么先讲 Java，因为 Kotlin 的语法结构和关键字是不一样的虽然实现的思路是一样的，所以先从 Java 开始，另外是近年 Jvm 版本升级很快，基础概念不会改变，但有新的特性是正常的，如果有常看文档的朋友会发现有些方法实现的方式和细节也会发生改变。</p><p>接下来开始 Kotlin 的部分，这部分看起来与 Java 8 相似，但实际上并没有使用 Java 8 的特性，但为了好理解一些可以写成类似的思路。</p><pre class=" language-Kotlin"><code class="language-Kotlin">    internal interface onTest {        fun onTestStandardMenthod()        fun onTestDefaultMethond() {            // 默认的逻辑        }        companion object {             fun onTestStaticMenthod() {                // 默认的逻辑             }        }    }    class TestActivity  :  AppCompatActivity , onTest{        override fun onCreate(savedInstanceState: Bundle?) {            super.onCreate(savedInstanceState)              // 通过类名调用的接口            onTest.onTestStaticMenthod()            // 通过对象的形式调用 代码只用来举例说明            TestActivity.onTestStandardMenthod()             TestActivity.onTestDefaultMethond()        }        // 必须实现        override fun onTestStandardMenthod(){}         // 可以选择性实现        override fun onTestDefaultMethond(){ super.onTestDefaultMethond()}    }</code></pre><p>Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现，如果对 Kotlin 的接口不明白的的话可以点这里<a href="https://www.kotlincn.net/docs/reference/interfaces.html" target="_blank" rel="noopener">查看更详细的说明</a>。</p><p>Kotlin 的接口可以选择是否有方法体，对比之下的话 Java8 需要声明 default 后可以有方法体，静态接口的方法其实在实现概念上是一样的，或许说目前的面向对象万变不离其中吧。</p><p>对于 Java8 这让我想到了之前朋友的吐槽 “苹果总是做一些以前就有的功能，然后开发布会来夸大其词，很厉害的样子” 我觉得 Java 就是这样子的，一些本应该随着时代来不断完善的语法或者新的优化，早应该就出了，结果非得在外界的冲击下，才做出改变。看更新的速度，很明显这并不是非常困难的事，这也就诞生了新的语言，世间常态总是如此当现有的工具诟病太多后，就会诞生新的工具，当然 Java 是必不可少的一环。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin 与 Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin 与 Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
