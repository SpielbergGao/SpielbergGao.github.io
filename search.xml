<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Handler</title>
      <link href="/handler/"/>
      <url>/handler/</url>
      
        <content type="html"><![CDATA[<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><code>Handler</code> 主要有俩个用途首先是可以用来定时处理或者分发消息，其次可以在其他线程中添加操作。当在子线程中进行耗时操作后需要更新 UI 时可以通过 <code>Handler</code> 将有关 UI 的操作切换到主线程中执行。</p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件:"></a>必要条件:</h3><ul><li>Message（消息）：需要被传递的消息其中包含了消息 ID，消息处理对象以及处理的数据等，由 <code>MessageQueue</code> 存储，最终由 <code>Handler</code> 处理。</li><li>MessageQueue（消息队列）：将 <code>Handler</code> 发送过来的消息存入一个消息队列中来依次执行，内部通过单链表的数据结构来维护消息列表。</li><li>Handler（处理者）：负责 <code>Message</code> 的发送及处理。通过 <code>Handler.sendMessage()</code> 向消息池发送各种消息事件,通过 <code>Handler.handleMessage()</code> 处理相应的消息事件。</li><li>Looper（消息泵）：通过 <code>Looper.loop()</code> 不断地从 <code>MessageQueue</code> 中抽取 <code>Message</code>，按分发机制将消息分发给目标处理者。<code>Looper</code> 不断从 <code>MessageQueue</code> 中获取消息并将之传递给消息处理者（即是消息发送者 <code>Handler</code> 本身）进行处理。</li></ul><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ul><li><code>Handler.sendMessage()</code> 发送消息时，会通过 <code>MessageQueue.enqueueMessage()</code> 向 <code>MessageQueue</code> 中添加一条消息。</li><li>通过 <code>Looper.loop()</code> 开启循环后，不断轮询调用 <code>MessageQueue.next()</code>；</li><li>调用目标 <code>Handler.dispatchMessage()</code> 去传递消息，目标 <code>Handler</code> 收到消息后调用 <code>Handler.handlerMessage()</code> 处理消息。</li></ul><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p><code>MessageQueue</code> 用来执行插入与读取的操作，使用 <code>enqueueMessage()</code> 往消息队列中插入一条消息， <code>next()</code> 的作用是从消息队列中取出一条消息并将其从消息队列中移除。其内部是使用一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。</p><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p><code>Looper</code> 类主要用于一个线程循环获取消息队列中的消息。<code>Looper</code> 的作用主要是负责管理消息队列，负责消息的出列和入列操作。</p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p><code>android.os.Message</code> 是定义一个 <code>Message</code> 包含必要的描述和属性数据，此对象可以被发送给 <code>android.os.Handler</code> 并关联到一个 <code>handler</code> 处理其中的消息。 <code>Message</code> 对象不是直接 <code>new</code> 出来的，只要调用 <code>handler</code> 中的 <code>obtainMessage</code> 方法来直接获得 <code>Message</code> 对象。<br>它的属性字段分别有：<code>arg1</code>、<code>arg2</code>、<code>what</code>、<code>obj</code>、<code>replyTo</code> 等，<code>arg1</code> 和 <code>arg2</code> 是用来存放整型数据的，<code>what</code> 是用来保存消息标示的<br><code>obj</code> 是 <code>Object</code> 类型的任意对象，<code>replyTo</code> 是消息管理器。</p><p>以上是 <code>Handler</code> 工作机制接下来看一下其内部的代码实现。</p><h3 id="Handler-内部实现"><a href="#Handler-内部实现" class="headerlink" title="Handler 内部实现"></a>Handler 内部实现</h3><h5 id="发送消息的形式"><a href="#发送消息的形式" class="headerlink" title="发送消息的形式"></a>发送消息的形式</h5><p>Handler 发送消息的形式主要有以下几种形式，其最终调用的都是 <code>sendMessageAtTime()</code> 方法</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span>  <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>delayMillis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            delayMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   </code></pre><p>可以看到 <code>sendMessageAtTime()</code> 方法中需要一个已初始化的 MessageQueue 类型的全局变量 <code>mQueue</code>，否则程序无法继续走下去</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            RuntimeException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" sendMessageAtTime() called with no mQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token string">"Looper"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>而 <code>mQueue</code> 变量是在构造函数中进行初始化的，且 <code>mQueue</code> 是成员常量，这说明 Handler 与 MessageQueue 是一一对应的关系，不可更改。</p><p>如果构造函数没有传入 <code>Looper</code> 参数，则会默认使用当前线程关联的 <code>Looper</code> 对象，<code>mQueue</code> 需要依赖于从 <code>Looper</code> 对象中获取，如果 <code>Looper</code> 对象为 <code>null</code> ，则会直接抛出异常，且从异常信息 <code>Can&#39;t create handler inside thread that has not called Looper.prepare()</code> 中可以看到，在向 Handler 发送消息前，需要先调用 <code>Looper.prepare()</code></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ···        mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                <span class="token string">"Can't create handler inside thread that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>        mCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>        mAsynchronous <span class="token operator">=</span> async<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="handler-sendMessage-msg"><a href="#handler-sendMessage-msg" class="headerlink" title="handler.sendMessage(msg)"></a>handler.sendMessage(msg)</h5><p>在 <code>enqueueMessage(queue, msg, uptimeMillis)</code> 这个方法中可以看到 <code>msg.target</code> 就是 Handler 本身，而这里的 <code>queue</code> 是 Handler 内部维护 Looper 所关联的 MessageQueue 对象。</p><pre class=" language-java"><code class="language-java">    handler<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//追踪到这一步</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            RuntimeException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" sendMessageAtTime() called with no mQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token string">"Looper"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>MessageQueue queue<span class="token punctuation">,</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        msg<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mAsynchronous<span class="token punctuation">)</span> <span class="token punctuation">{</span>            msg<span class="token punctuation">.</span><span class="token function">setAsynchronous</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">enqueueMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="Looper轮训操作"><a href="#Looper轮训操作" class="headerlink" title="Looper轮训操作"></a>Looper轮训操作</h5><p>在Looper 类中，可以看到，<code>myLooper()</code> 方法是从 <code>sThreadLocal</code> 对象中获取 Looper 对象的，<code>sThreadLocal</code> 对象又是通过 <code>prepare(boolean)</code> 来进行赋值的，且该方法只允许调用一次，一个线程只能创建一个 Looper 对象，否则将抛出异常。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Looper<span class="token operator">></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>Looper<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token annotation punctuation">@Nullable</span> Looper <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//只允许赋值一次</span>        <span class="token comment" spellcheck="true">//如果重复赋值则抛出异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>此处除了因为 <code>prepare(boolean)</code> 多次调用会抛出异常导致无法关联多个 Looper 外，Looper 类的构造函数也是私有的，且在构造函数中还初始化了一个线程常量 <code>mThread</code>，这都说明了 Looper 只能关联到一个线程，且关联之后不能改变。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">final</span> Thread mThread<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>        mThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>查找该方法的所有引用，可以发现在 Looper 类中有如下方法，从名字来看，可以猜测该方法是由主线程来调用的，查找其引用。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Looper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainLooper <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"The main Looper has already been prepared."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            sMainLooper <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>在 ActivityThread 类的 main() 方法中可以看到在主线程做了 Handler 的初始化操作所以在主线程中可以直接使用 Handler。如果是在子线程中创建 Handler 则需要手动来调用 Looper.prepare() 方法。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ···        Looper<span class="token punctuation">.</span><span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ActivityThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActivityThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainThreadHandler <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sMainThreadHandler <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMessageLogging</span><span class="token punctuation">(</span><span class="token keyword">new</span>                    <span class="token class-name">LogPrinter</span><span class="token punctuation">(</span>Log<span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span> <span class="token string">"ActivityThread"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// End of event ActivityThreadMain.</span>        Trace<span class="token punctuation">.</span><span class="token function">traceEnd</span><span class="token punctuation">(</span>Trace<span class="token punctuation">.</span>TRACE_TAG_ACTIVITY_MANAGER<span class="token punctuation">)</span><span class="token punctuation">;</span>        Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Main thread loop unexpectedly exited"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 范型与 Kotlin 范型</title>
      <link href="/java-fan-xing-yu-kotlin-fan-xing/"/>
      <url>/java-fan-xing-yu-kotlin-fan-xing/</url>
      
        <content type="html"><![CDATA[<p>Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常。<br>Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。</p><h3 id="范型的好处"><a href="#范型的好处" class="headerlink" title="范型的好处"></a>范型的好处</h3><ol><li>类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。</li><li>消除了代码中许多的强制类型转换，增强了代码的可读性。</li><li>为较大的优化带来了可能。优化了程序设计，解决了黄色警告线。</li></ol><p>关于范型需要了解<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="noopener">逆变与协变</a>，因为涉及到上下变型关系不了解的话容易绕晕。<br>翻译在解决了类型转换的问题后，发先了继承关系中类型不一致的问题。逆变与协变就是为了解决这种问题，平时开发中也会经常用到。<br>我们在基础的架构时会对数据进行封装或者根据逻辑的层级结构进行封装都会用到。不要害怕。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// Java 协变写法 strong</span>    List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Java 逆变写法</span>    List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Number<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin">    <span class="token comment" spellcheck="true">// Kotlin 协变写法</span>    <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span><span class="token keyword">out</span> Number<span class="token operator">></span> <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Kotlin 逆变写法</span>    <span class="token keyword">val</span> list<span class="token operator">:</span> MutableList<span class="token operator">&lt;</span><span class="token keyword">in</span> Int<span class="token operator">></span> <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>Number<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>型变（协变和逆变）涉及到集合元素，集合类。协变讲的是两个集合的元素是子类关系，这两个集合也是子类关系，有了子类关系，就可以用多态表示。逆变的关系是反过来的，逆变说得是，两个集合的元素是父类关系，这两个集合却能成为子类关系。</p><h3 id="Kotlin-投影与-Java-通配符-？-差异"><a href="#Kotlin-投影与-Java-通配符-？-差异" class="headerlink" title="Kotlin * 投影与 Java 通配符 ？ 差异"></a>Kotlin * 投影与 Java 通配符 ？ 差异</h3><pre class=" language-kotlin"><code class="language-kotlin">    <span class="token comment" spellcheck="true">// kotlin * 投影</span>    <span class="token keyword">val</span> clazz<span class="token operator">:</span>Class<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token operator">=</span> List<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">.</span>java</code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// Java ? 通配符</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>摘录一段 Kotlin 官方对 <code>*</code> 说明:</p><ul><li>对于 <code>Foo &lt;out T&gt;</code>，其中 T 是一个具有上界 TUpper 的协变类型参数，<code>Foo &lt;*&gt;</code> 等价于 <code>Foo &lt;out TUpper&gt;</code>。 这意味着当 T 未知时，你可以安全地从 <code>Foo &lt;*&gt;</code> 读取 TUpper 的值。</li><li>对于 <code>Foo &lt;in T&gt;</code>，其中 T 是一个逆变类型参数，<code>Foo &lt;*&gt;</code> 等价于 <code>Foo &lt;in Nothing&gt;</code>。 这意味着当 T 未知时，没有什么可以以安全的方式写入 <code>Foo &lt;*&gt;</code>。</li><li>对于 <code>Foo &lt;T&gt;</code>，其中 T 是一个具有上界 TUpper 的不型变类型参数，<code>Foo&lt;*&gt;</code> 对于读取值时等价于 <code>Foo&lt;out TUpper&gt;</code> 而对于写值时等价于 <code>Foo&lt;in Nothing&gt;</code>。</li></ul><p><code>*</code> 投影不适用与函数及变量的类型范型参数，不能作为弗雷多额范型参数传入。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin 与 Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创业团队经历与总结</title>
      <link href="/ge-ren-zong-jie/"/>
      <url>/ge-ren-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>在这里我总结一下工作中与生活中遇到的事情。</p><p>在2019年7月入职一家创业团队，在入职前已经做好最累的打算实际上我做的打算与遇到的差距还不小。工作是 996 的性质，但是实际上大多数下班时间是在10点或这更晚一些。回到住的地方大概时间是在11点左右。<br>起初还能保持每晚1个小时的学习随着时间变长，就无法再持续下去。</p><p>每周1-2次的版本迭代与 Bug 修复加剧了精力与激情的消耗。成为了一个不折不扣的机器不会思考生活每天只有面临的各种问题。没过试用期的时候曾想着要不要结束，但是我觉得困难是会过去的不能向困难低头。</p><p>团队没有规范的流程，大多数开发的时候会临时加入其他的需求或者要发版上线的时候加新的需求。一开始我是拒绝的因为我不能保证不会出问题没有专业的测试，长期以往就失去了对生活与工作的希望一点都不夸张。</p><p>致使我最终决定离开团队的原因是，我感受不到我是一个员工，更多的是我是这个团队的写代码机器，负责人要求技术晚上不能关机不能静音随时在线（这里我吐槽一下，负责人平时晚上到公司开始他的工作直到半夜还会在微信群中提出问题），这让我感到痛苦我本身就有睡眠质量差的问题。有一次的版本迭代中我很累坚持不住也被强行要求发版上线一直工作到凌晨。<br>甚至希望周日也在工作，创业团队艰难我是可以理解的，但是这样让我觉得团队需要的是一个机器而不是一个伙伴，我也没有说什么在最后一次迭代后提出了离职。不合适就没必要继续留下去，对双方来说都是损失。</p><p>另一位同事在年前休息的时候接到电话说年后不需要到公司了。具体原因我不清楚，团队的结构是后台1人，iOS 1人 Android 1人，被辞退的同事被找来没有过试用期他是新招的后台。除了我，技术的另外俩位同事是创始人。</p><p>上面是我的一些吐槽。接下来我说一下我的个人总结，如果选择创业团队一定要看负责人，负责人如果没有经验那么多半是无法快速的带领团队走向目标，因为缺少经验意味着要一点点去尝试，负责人的人品与格局也很重要，这决定身边一起奋斗是伙伴还是机器。<br>要时刻保持学习，哪怕有一点点的时间也要深入的学习，因为这是对自己的负责，即便连续工作十几个小时，因为投资自己才能提高生存的几率，要思考，在繁重的工作中思维会有一个潜意识想法，我要修复这个问题因为还有很多问题和功能要做，有了这个想法就会变成一种为了写功能而写功能，没有思考的能力。</p><p>最后我没有对团队的抱怨的心态，感谢团队的知遇之恩，因为我离开后始终会有合适的朋友继续在那个岗位工作，也反思自己因为身体的疲累而放弃学习，放弃自我的提升。也意识到不管什么时候要思考，即便自己的提议不被接受也要保持自己的思考，因为时间久了就不会思考了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConstraintLayout 属性简介</title>
      <link href="/constraintlayout/"/>
      <url>/constraintlayout/</url>
      
        <content type="html"><![CDATA[<p>在日常开发中会遇到多种布局结构，导致 xml 层级嵌套过多，xml 又是 IO 操作，在 vSync 信号量通知界面绘制刷新时可能会造成卡顿当然原因会有多种，这里做一个例子。</p><p>使用 ConstraintLayout 可以有效的避免层级嵌套过深问题，日常开发中一个层级就可以搞定之前多层级嵌套的布局。它的众多属性非常的灵活简单易用。</p><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>相对定位属性的特点是 constraint 后边的方向是指当前控件的位置，下划线后的方向是指定控件的位置。</p><ul><li>layout_constraintLeft_toLeftOf</li><li>layout_constraintLeft_toRightOf</li><li>layout_constraintRight_toLeftOf</li><li>layout_constraintRight_toRightOf</li><li>layout_constraintTop_toTopOf</li><li>layout_constraintTop_toBottomOf</li><li>layout_constraintBottom_toTopOf</li><li>layout_constraintBottom_toBottomOf</li><li>layout_constraintBaseline_toBaselineOf</li><li>layout_constraintStart_toEndOf</li><li>layout_constraintStart_toStartOf</li><li>layout_constraintEnd_toStartOf</li><li>layout_constraintEnd_toEndOf</li></ul><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- buttonB 设置了约束属性将自己的左边设置在 buttonA 的右边  --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonA<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>         <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonB<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintLeft_toRightOf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonA<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h2 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h2><ul><li>android:layout_marginStart</li><li>android:layout_marginEnd</li><li>android:layout_marginLeft</li><li>android:layout_marginTop</li><li>android:layout_marginRight</li><li>android:layout_marginBottom</li></ul><p>上面的属性是常规设置边距，使用方法和 LinearLayout 及 RelateLayout 无异，下面的属性就比较有趣了，在布局中会用到 <code>GONE</code>，当使用这个属性后有一个问题当该控件再次显示的时候会触发绘制，就会有一个屏幕跳动的问题，当使用一下属性时可以设置在 <code>GONE</code> 状态下与指定目标的位置，在显示的时候可以避免这种问题。</p><ul><li>layout_goneMarginStart</li><li>layout_goneMarginEnd</li><li>layout_goneMarginLeft</li><li>layout_goneMarginTop</li><li>layout_goneMarginRight</li><li>layout_goneMarginBottom</li></ul><h2 id="居中定位"><a href="#居中定位" class="headerlink" title="居中定位"></a>居中定位</h2><p>这俩个属性可以更改属性偏移位置，视图同时设置 <code>layout_constraintStart_toStartOf</code> 及 <code>layout_constraintEnd_toEndOf</code> 会默认为居中也就是 50%，通过以下俩个属性可以更改居中的位置。</p><ul><li>layout_constraintHorizontal_bias</li><li>layout_constraintVertical_bias</li></ul><h2 id="圆形定位"><a href="#圆形定位" class="headerlink" title="圆形定位"></a>圆形定位</h2><ul><li>layout_constraintCircle : 引用另一个小部件ID</li><li>layout_constraintCircleRadius : 到另一个小部件中心的距离</li><li>layout_constraintCircleAngle : 小部件应处于的角度（以度为单位，从0到360）</li></ul><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonA<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>         <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonB<span class="token punctuation">"</span></span> <span class="token attr-name">...</span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintCircle</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/buttonA<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintCircleRadius</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintCircleAngle</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>45<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h2 id="尺寸限制"><a href="#尺寸限制" class="headerlink" title="尺寸限制"></a>尺寸限制</h2><h3 id="MATCH-CONSTRAINT尺寸"><a href="#MATCH-CONSTRAINT尺寸" class="headerlink" title="MATCH_CONSTRAINT尺寸"></a>MATCH_CONSTRAINT尺寸</h3><p>当尺寸设置为时 MATCH_CONSTRAINT，默认行为是使结果尺寸占用所有可用空间。可以使用其他几个修饰符：</p><ul><li>layout_constraintWidth_min和layout_constraintHeight_min：将为此尺寸设置最小尺寸</li><li>layout_constraintWidth_max和layout_constraintHeight_max：将为此尺寸设置最大尺寸</li><li>layout_constraintWidth_percent和layout_constraintHeight_percent：将此尺寸的尺寸设置为父尺寸的百分比</li></ul><h3 id="最小与最大"><a href="#最小与最大" class="headerlink" title="最小与最大"></a>最小与最大</h3><ul><li>尺寸应设置为 MATCH_CONSTRAINT（0dp）</li><li>默认值应设置为百分比app:layout_constraintWidth_default=”percent” 或 app:layout_constraintHeight_default=”percent”</li><li>然后将 layout_constraintWidth_percent 或 layout_constraintHeight_percent 属性设置为介于 0 和 1 之间的值<br>比</li></ul><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!--浮点值，表示宽度和高度之间的比率形式为“宽度：高度”的比率 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>         <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_constraintDimensionRatio</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1:1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>以上内容是摘录至文档部分内容。在使用中如果以某一个控件为位置主导，那该控件要设置四个约束属性，不然未设置的那个属性会出现变形或移位的问题，当控件 A 底部设置在 控件 B 顶部时，那么控件 B 也要设置顶部到控件 A 的底部，开环与闭环原则。</p><p>match 这个可以用 <code>0dp</code> 代替并设置控件的约束位置，如果使用 match 会有超出可见范围的问题。</p><p>有另一种更简单的方法设置就是使用 Android Studio 的 <code>Design</code> 模式可以通过点击的方式进行设置各种属性的大概位置，精确的位置需要手动调整。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 接口与 Java8 新特性接口</title>
      <link href="/kotlin-java8/"/>
      <url>/kotlin-java8/</url>
      
        <content type="html"><![CDATA[<p>在看一本关于高性能编程的时候发现 Java8 中关于接口的新特性的介绍，这个特性是真的棒，解决了一个接口中有多个方法，但并不想实现该接口的类都去实现所有的方法，简单的说就是在类需要的情况再去重写接口。所以有了以下的特性出现。</p><h2 id="接口增强"><a href="#接口增强" class="headerlink" title="接口增强"></a>接口增强</h2><p>在 Java8 的中接口特性中增加以下俩种特性:</p><ul><li><p>在接口中可以使用 default 关键字修饰默认方法或扩展方法，抽象方法因为其特性的原因无法使用</p></li><li><p>接口可以使用 static 声明为静态方法，可以通过类直接调用</p><p>   Android Studio 中使用 Java8 需要在模块中的 build.gradle 中配置指定的版 Java 版本，当然使用 Kotlin 为开发语言的话需要为 Kotlin 指定 Jvm 版本，因为 Kotlin 使用的是 Jvm 1.6 那么下面就来展示他们的配置方法：</p><pre class=" language-groovy"><code class="language-groovy">        android <span class="token punctuation">{</span>            defaultConfig <span class="token punctuation">{</span>                <span class="token punctuation">...</span>                  kotlinOptions <span class="token punctuation">{</span>                    jvmTarget <span class="token operator">=</span> <span class="token string">'1.8'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            compileOptions <span class="token punctuation">{</span>                sourceCompatibility JavaVersion<span class="token operator">.</span>VERSION_1_8                targetCompatibility JavaVersion<span class="token operator">.</span>VERSION_1_8            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>   经过以上的配置就可以使用 Java8 的新特性了</p></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h3><pre class=" language-java"><code class="language-java">    puclic <span class="token keyword">interface</span> <span class="token class-name">onTest</span><span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">onTestStandardMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">onTestDefaultMethond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 默认的逻辑</span>        <span class="token punctuation">}</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">onTestStaticMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 默认的逻辑</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token keyword">implements</span> <span class="token class-name">onTest</span><span class="token punctuation">{</span>       <span class="token annotation punctuation">@Override</span>       <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 通过类名调用的接口</span>        onTest<span class="token punctuation">.</span><span class="token function">onTestStaticMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过对象的形式调用 代码只用来举例说明</span>        <span class="token keyword">new</span> <span class="token class-name">TestActivity<span class="token punctuation">.</span>onTestStandardMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">new</span> <span class="token class-name">TestActivity<span class="token punctuation">.</span>onTestDefaultMethond</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onTestStandardMenthod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 必须实现</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onTestDefaultMethond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 可以选择性实现</span>    <span class="token punctuation">}</span></code></pre><p>上面的代码是展示如何使用，如果对具体的细节想了解的更清楚可以查看官方的<a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">文档</a></p><p>可能有朋友好奇我为什么先讲 Java，因为 Kotlin 的语法结构和关键字是不一样的虽然实现的思路是一样的，所以先从 Java 开始，另外是近年 Jvm 版本升级很快，基础概念不会改变，但有新的特性是正常的，如果有常看文档的朋友会发现有些方法实现的方式和细节也会发生改变。</p><p>接下来开始 Kotlin 的部分，这部分看起来与 Java 8 相似，但实际上并没有使用 Java 8 的特性，但为了好理解一些可以写成类似的思路。</p><pre class=" language-Kotlin"><code class="language-Kotlin">    internal interface onTest {        fun onTestStandardMenthod()        fun onTestDefaultMethond() {            // 默认的逻辑        }        companion object {             fun onTestStaticMenthod() {                // 默认的逻辑             }        }    }    class TestActivity  :  AppCompatActivity , onTest{        override fun onCreate(savedInstanceState: Bundle?) {            super.onCreate(savedInstanceState)              // 通过类名调用的接口            onTest.onTestStaticMenthod()            // 通过对象的形式调用 代码只用来举例说明            TestActivity.onTestStandardMenthod()             TestActivity.onTestDefaultMethond()        }        // 必须实现        override fun onTestStandardMenthod(){}         // 可以选择性实现        override fun onTestDefaultMethond(){ super.onTestDefaultMethond()}    }</code></pre><p>Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现，如果对 Kotlin 的接口不明白的的话可以点这里<a href="https://www.kotlincn.net/docs/reference/interfaces.html" target="_blank" rel="noopener">查看更详细的说明</a>。</p><p>Kotlin 的接口可以选择是否有方法体，对比之下的话 Java8 需要声明 default 后可以有方法体，静态接口的方法其实在实现概念上是一样的，或许说目前的面向对象万变不离其中吧。</p><p>对于 Java8 这让我想到了之前朋友的吐槽 “苹果总是做一些以前就有的功能，然后开发布会来夸大其词，很厉害的样子” 我觉得 Java 就是这样子的，一些本应该随着时代来不断完善的语法或者新的优化，早应该就出了，结果非得在外界的冲击下，才做出改变。看更新的速度，很明显这并不是非常困难的事，这也就诞生了新的语言，世间常态总是如此当现有的工具诟病太多后，就会诞生新的工具，当然 Java 是必不可少的一环。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin 与 Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
