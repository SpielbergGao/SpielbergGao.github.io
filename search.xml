<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kotlin 接口与 Java8 新特性接口</title>
      <link href="/Kotlin-Java8/"/>
      <url>/Kotlin-Java8/</url>
      
        <content type="html"><![CDATA[<p>在看一本关于高性能编程的时候发现 Java8 中关于接口的新特性的介绍，这个特性是真的棒，解决了一个接口中有多个方法，但并不想实现该接口的类都去实现所有的方法，简单的说就是在类需要的情况再去重写接口。所以有了以下的特性出现。</p><h2 id="接口增强"><a href="#接口增强" class="headerlink" title="接口增强"></a>接口增强</h2><p>在 Java8 的中接口特性中增加以下俩种特性:</p><ul><li><p>在接口中可以使用 default 关键字修饰默认方法或扩展方法，抽象方法因为其特性的原因无法使用</p></li><li><p>接口可以使用 static 声明为静态方法，可以通过类直接调用</p><p>   Android Studio 中使用 Java8 需要在模块中的 build.gradle 中配置指定的版 Java 版本，当然使用 Kotlin 为开发语言的话需要为 Kotlin 指定 Jvm 版本，因为 Kotlin 使用的是 Jvm 1.6 那么下面就来展示他们的配置方法：</p>   <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">... </span><br><span class="line"> kotlinOptions &#123;</span><br><span class="line">        jvmTarget = <span class="string">'1.8'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   经过以上的配置就可以使用 Java8 的新特性了</p></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">puclic <span class="class"><span class="keyword">interface</span> <span class="title">onTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onTestStandardMenthod</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onTestDefaultMethond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 默认的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onTestStaticMenthod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 默认的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">onTest</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过类名调用的接口</span></span><br><span class="line">    onTest.onTestStaticMenthod();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过对象的形式调用 代码只用来举例说明</span></span><br><span class="line">    <span class="keyword">new</span> TestActivity.onTestStandardMenthod() </span><br><span class="line">    <span class="keyword">new</span> TestActivity.onTestDefaultMethond()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTestStandardMenthod</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 必须实现</span></span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTestDefaultMethond</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 可以选择性实现</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是展示如何使用，如果对具体的细节想了解的更清楚可以查看官方的<a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">文档</a></p><p>可能有朋友好奇我为什么先讲 Java，因为 Kotlin 的语法结构和关键字是不一样的虽然实现的思路是一样的，所以先从 Java 开始，另外是近年 Jvm 版本升级很快，基础概念不会改变，但有新的特性是正常的，如果有常看文档的朋友会发现有些方法实现的方式和细节也会发生改变。</p><p>接下来开始 Kotlin 的部分，这部分看起来与 Java 8 相似，但实际上并没有使用 Java 8 的特性，但为了好理解一些可以写成类似的思路。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">interface</span> <span class="title">onTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onTestStandardMenthod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onTestDefaultMethond</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 默认的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123; </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onTestStaticMenthod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 默认的逻辑 </span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span>  :  <span class="type">AppCompatActivity </span>, <span class="type">onTest&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">  <span class="comment">// 通过类名调用的接口</span></span><br><span class="line">onTest.onTestStaticMenthod()</span><br><span class="line"><span class="comment">// 通过对象的形式调用 代码只用来举例说明</span></span><br><span class="line">TestActivity.onTestStandardMenthod() </span><br><span class="line">TestActivity.onTestDefaultMethond()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 必须实现</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTestStandardMenthod</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line"><span class="comment">// 可以选择性实现</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTestDefaultMethond</span><span class="params">()</span></span>&#123; <span class="keyword">super</span>.onTestDefaultMethond()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现，如果对 Kotlin 的接口不明白的的话可以点这里<a href="https://www.kotlincn.net/docs/reference/interfaces.html" target="_blank" rel="noopener">查看更详细的说明</a>。</p><p>Kotlin 的接口可以选择是否有方法体，对比之下的话 Java8 需要声明 default 后可以有方法体，静态接口的方法其实在实现概念上是一样的，或许说目前的面向对象万变不离其中吧。</p><p>对于 Java8 这让我想到了之前朋友的吐槽 “苹果总是做一些以前就有的功能，然后开发布会来夸大其词，很厉害的样子” 我觉得 Java 就是这样子的，一些本应该随着时代来不断完善的语法或者新的优化，早应该就出了，结果非得在外界的冲击下，才做出改变。看更新的速度，很明显这并不是非常困难的事，这也就诞生了新的语言，世间常态总是如此当现有的工具诟病太多后，就会诞生新的工具，当然 Java 是必不可少的一环。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
